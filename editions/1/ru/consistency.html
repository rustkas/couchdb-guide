<title>Eventual Consistency</title>

<meta charset="utf-8">

<link rel="stylesheet" href="../../../style.css">

<link rel="prev" href="why.html">

<link rel="next" href="tour.html">

<script src="../../../script.js"></script>

<h2 id="consistency">Возможная последовательность</h2>

<p>
В предыдущей главе мы увидели, что гибкость CouchDB позволяет нам развивать наши данные по мере роста и изменения наших приложений. В этой главе мы рассмотрим, как работа «с ядром» CouchDB способствует простоте наших приложений и помогает нам естественным образом создавать масштабируемые, распределенные системы.

<h3 id="grain">Работа с ядром</h3>

<p>
<em>Распределенная система</em> - это система, которая надежно работает в распределённой сети. Особенностью сетевых вычислений является то, что сетевые ссылки могут потенциально исчезнуть, и существует множество стратегий для управления этим типом сегментации сети. CouchDB отличается от других тем, что допускает возможную согласованность, а не ставит абсолютную согласованность выше необработанной доступности, такой как RDBMS или Paxos. Общим для этих систем является понимание того, что данные действуют по-разному, когда многие люди получают к ним доступ одновременно. Их подходы различаются, когда речь заходит о том, какие аспекты <em>согласованности</em>, <em>доступности</em> или <em>устойчивость к разделению</em> имеют приоритет.

<p>Внутреннее устройство распределённых систем может быть весьма сложным. Многие из предостережений и «ошибок», с которыми вы столкнетесь с течением времени, не сразу очевидны. У нас нет всех решений, и CouchDB не является панацеей, но когда вы правильно применяем идеи, которые заложены в ядре CouchDB, путь наименьшего сопротивления приводит вас к естественно масштабируемым приложениям.

<p>Конечно, построение распределенной системы - это только начало. Веб-сайт с базой данных, не всегда доступной, практически бесполезен. К сожалению, традиционный подход к согласованности в реляционных базах данных позволяет программистам приложений очень легко полагаться на глобальное состояние, глобальные часы и другие высоконадежные функции, даже не осознавая, что они делают это. Перед рассмотрением того, как CouchDB способствует масштабируемости, мы рассмотрим ограничения, с которыми сталкивается распределенная система. После того, как мы увидели проблемы, которые возникают, когда части вашего приложения не могут полагаться на постоянный контакт друг с другом, мы увидим, что CouchDB предоставляет интуитивно понятный и полезный способ для моделирования приложений на основе высокой доступности.

<h3 id="cap">Теорема CAP (Сonsistency, Availability, Partition tolerance)</h3>

<p>Теорема CAP описывает несколько различных стратегий для распределения логики приложения в сети. Решение CouchDB использует репликацию для распространения изменений приложения между участвующими узлами. Это принципиально иной подход, чем согласованные алгоритмы и реляционные базы данных, которые работают на разных пересечениях согласованности, доступности и устойчивости к разделению.
<p>Теорема CAP, продемонстрирована на <a href="#figure/1">Рисунок 1, "Теорема CAP"</a>, определяет три различных проблемы:

<dl>

<dt>Согласованности (Consistency)</dt>

<dd>Все клиенты базы данных видят одни и те же данные, даже с одновременными обновлениями.</dd>

<dt>Доступности (Availability)</dt>

<dd>Все клиенты базы данных могут получить доступ к какой-либо версии данных.</dd>

<dt>Устойчивость к разделению (Partition tolerance)</dt>

<dd>База данных может быть разделена на несколько серверов.</dd>

</dl>

<p>

<div class="figure" id="figure/1">

<img src="consistency/01.png">

<p class="caption">Рисунок 1. Теорема CAP 

</div>

<p>Когда система становится настолько большой, что один узел базы данных не может справиться с возложенной на нее нагрузкой, разумным ли решением является добавление большего количества серверов. Когда мы добавляем узлы, мы должны начать думать о том, как разделить данные между ними. У нас есть несколько баз данных с одинаковыми данными? Размещаем ли мы разные наборы данных на разных серверах баз данных? Разрешаем ли мы только определенным серверам баз данных записывать данные, а другим разрешать чтение?

<p>Независимо от того, какой подход мы выберем, единственной проблемой, с которой мы будем сталкиваться, является синхронизация всех этих серверов баз данных. Если вы записываете некоторую информацию на один узел, как вы собираетесь убедиться, что запрос на чтение на другой сервер базы данных отражает эту новейшую информацию? Могут быть миллисекундные задержки. Даже при скромной совокупности серверов баз данных эта проблема может стать чрезвычайно сложной.

<p>Когда абсолютно необходимо, чтобы все клиенты видели единообразное представление базы данных, пользователям одного узла придется подождать, пока другие узлы не придут к согласию, прежде чем они смогут читать или записывать в базу данных. В этом случае мы видим, что <em>Доступность</em> менее важно, чем <em>Согласованность</em>. Тем не менее, существуют ситуации, когда доступность превосходит согласованность:

<blockquote>

<p>Каждый узел в системе должен иметь возможность принимать решения исключительно на основе локального состояния. Если вам нужно что-то делать под высокой нагрузкой при возникновении сбоев - у вас серьёзная проблема (делема). Если вы беспокоитесь о масштабируемости, любой алгоритм, который заставляет вас выполнять соглашение, в конечном итоге станет вашим узким местом. Примите это как данность.
<p class="attribution">&mdash;Werner Vogels, Начальник технического отдела и заместитель Президента компании Amazon 

</blockquote>

<p>Если доступность является приоритетом, мы можем позволить клиентам записывать данные в один узел базы данных, не дожидаясь согласия других узлов. Если база данных знает, как позаботиться о согласовании этих операций между узлами, мы достигаем своего рода «возможной согласованности» в обмен на высокую доступность. Это удивительно применимый компромисс для многих приложений.

<p>В отличие от традиционных реляционных баз данных, где каждое выполняемое действие обязательно подвергается проверкам согласованности в рамках всей базы данных, CouchDB действительно упрощает создание приложений, которые жертвуют немедленной согласованностью ради огромных улучшений производительности, которые сопровождаются простым распространением.
<h3 id="local">Локальная согласованность</h3>

<p>Прежде чем мы попытаемся понять, как CouchDB работает в кластере, важно понять внутреннюю работу одного узла CouchDB. CouchDB API разработан для обеспечения удобной, но тонкой оболочки вокруг ядра базы данных. При более внимательном рассмотрении структуры ядра базы данных у нас будет лучшее понимание API, который его окружает.
<h4 id="key">Идентификация данных</h4>

<p>Ключевым элементом СУБД CouchDB является мощный механизм хранения на основе <em>бинарных деревьев (B-tree)</em>. Бинарное дерево - это отсортированная структура данных, которая позволяет выполнять поиск, вставку и удаление. Как показывает <a href="#figure/2"> рисунок 2 «Структура запроса представления» </a>, CouchDB использует этот механизм хранения B-дерева для всех внутренних данных, документов и представлений. Если вы поймете как работает этот механизм, вам будет легче понять более сложные темы.
<div class="figure" id="figure/2">

<img src="consistency/02.png">

<p class="caption">Рисунок 2. Структура запроса представления

</div>

<p>CouchDB использует MapReduce для вычисления результатов представления. MapReduce использует две функции, «map» и «reduce», которые применяются к каждому документу в отдельности. Возможность изолировать эти операции означает, что вычисления представлений поддаются параллельным и инкрементным вычислениям. Что еще более важно, поскольку эти функции создают пары ключ / значение, CouchDB может вставить их в механизм хранения B-дерева, отсортированный по ключу. Поиск по ключу или диапазону ключей является чрезвычайно эффективной операцией с B-деревом, описанным в <em>big O notation</em> как <em>O (log N)</em> и <em>O (log N + K)</em> соответственно.
<p>В CouchDB мы получаем доступ к документам и просматриваем результаты по ключу или диапазону ключей. Это прямое сопоставление с базовыми операциями, выполняемыми над механизмом хранения B-дерева CouchDB. Наряду со вставками и обновлениями документов, это прямое сопоставление является причиной, по которой мы описываем API CouchDB как тонкую оболочку вокруг ядра базы данных.
<p>Being able to access results by key alone is a very important restriction because it allows us to make huge performance gains. As well as the massive speed improvements, we can partition our data over multiple nodes, without affecting our ability to query each node in isolation. <em>BigTable</em>, <em>Hadoop</em>, <em>SimpleDB</em>, and <em>memcached</em> restrict object lookups by key for exactly these reasons.
Возможность доступа к результатам по одному ключу является очень важным ограничением, поскольку позволяет нам значительно повысить производительность. Помимо значительного улучшения скорости, мы можем разделить наши данные на несколько узлов, не влияя на нашу способность делать запрос к конкретному узлу в отдельности. <em>BigTable</em>, <em>Hadoop</em>, <em>SimpleDB </em> и <em>memcached</em> ограничивают поиск объектов по ключу именно по этим причинам.
<h4 id="locking">Отсутствие блокировок</h4>

<p>Таблица в реляционной базе данных представляет собой единую структуру данных. Если вы хотите изменить таблицу, скажем, обновить строку, система базы данных должна убедиться, что никто другой не пытается обновить эту строку и что никто не может читать из этой строки во время ее обновления. Обычный способ справиться с этим - это так называемый <em>блокировка</em>. Если несколько клиентов хотят получить доступ к таблице, первый клиент получает блокировку, заставляя всех ждать. Когда обрабатывается запрос первого клиента, следующему клиенту предоставляется доступ, в то время как все остальные ждут, и так далее. Такое последовательное выполнение запросов, даже когда они поступают параллельно, приводит к значительному снижению вычислительной мощности вашего сервера. При высокой нагрузке реляционная база данных может тратить больше времени на выяснение того, кому разрешено делать и в каком порядке, чем на какую-либо реальную работу.
<p>Вместо блокировок CouchDB использует <em>управления параллелизмом с возможностью использовать множество версий [Multi-Version Concurrency Control (MVCC)]</em> для управления одновременным доступом к базе данных. <a href="#figure/3"> Рисунок 3, «MVCC означает отсутствие блокировки»</a> иллюстрирует различия между MVCC и традиционными механизмами блокировки. MVCC означает, что CouchDB может работать на полной скорости, постоянно, даже при высокой нагрузке. Запросы выполняются параллельно, что позволяет превосходно использовать каждую последнюю нагрузку на ваш сервер.
<div class="figure" id="figure/3">

<img src="consistency/03.png">

<p class="caption">Рисунок 3. MVCC предоставляет отсутствие блокировок

</div>

<p>Документы в CouchDB имеют версии, как и в обычной системе контроля версий, такой как Subversion. Если вы хотите изменить значение в документе, вы создаете новую версию этого документа и сохраняете ее поверх старой. После этого вы получите две версии одного и того же документа, одну старую и одну новую.
<p>Как это предлагает улучшение по сравнению с блокировками? Рассмотрим набор запросов, желающих получить доступ к документу. Первый запрос читает документ. Пока это обрабатывается, второй запрос изменяет документ. Поскольку второй запрос включает в себя совершенно новую версию документа, CouchDB может просто добавить его в базу данных, не дожидаясь завершения запроса на чтение.
<p>Когда третий запрос хочет прочитать тот же документ, CouchDB укажет на новую версию, которая была только что написана. В течение всего этого процесса первым запросом может быть чтение исходной версии.
<p>Запрос на чтение всегда будет видеть самый последний снимок вашей базы данных.
<h4 id="validation">Проверка</h4>

<p>Как разработчики приложений, мы должны думать о том, какие входные данные мы должны принять и что мы должны отклонить. Ясная способность выполнять этот тип проверки над сложными данными <em>в</em> традиционной реляционной базе данных оставляет желать лучшего. К счастью, CouchDB предоставляет мощный способ проверки каждого документа из базы данных.
<p>CouchDB может проверять документы, используя функции JavaScript, аналогичные тем, которые используются для MapReduce. Каждый раз, когда вы пытаетесь изменить документ, CouchDB передает функции проверки копию существующего документа, копию нового документа и коллекцию дополнительной информации, такой как данные аутентификации пользователя. Функция проверки теперь имеет возможность одобрить или отклонить обновление.
<p>Работая со структурой и позволяя CouchDB делать это за нас, мы экономим огромное количество циклов ЦП, которые в противном случае были бы потрачены на сериализацию графов объектов из SQL, преобразование их в объекты домена и использование этих объектов для проверки на уровне приложения.
<h3 id="distributed">Устойчивость к разделению</h3>

<p>Поддержание согласованности в пределах одного узла базы данных является относительно простым для большинства баз данных. Реальные проблемы начинают проявляться, когда вы пытаетесь поддерживать согласованность между несколькими серверами баз данных. Если клиент выполняет операцию записи на сервере <em>A</em>, как мы можем убедиться, что это согласуется с сервером <em>B</em> или <em>C</em> или <em>D</em>? Для реляционных баз данных это очень сложная проблема, решениям которой посвящены целые книги. Вы можете использовать различные решения: мультимастер, ведущий/ведомый, разделение, кэши сквозные записи и все виды других сложных методов.
<h4 id="incremental">Инкрементная репликация</h4>

<p>Поскольку операции CouchDB выполняются в контексте одного документа, если вы хотите использовать два узла базы данных, вам больше не нужно беспокоиться о том, чтобы они оставались в постоянной связи. CouchDB обеспечивает <em>возможную согласованность</em> между базами данных, используя инкрементную репликацию, процесс, в котором изменения документа периодически копируются между серверами. Мы можем создать так называемый кластер баз данных <em>ничего не разделяемый</em>, где каждый узел является независимым и самодостаточным, не оставляя единой точки раздора в системе.
<p>Нужно масштабировать кластер базы данных CouchDB? Просто добавьте другой сервер.
<p>
Как показано на <a href="#figure/4"> Рисуноке 4, «Инкрементная репликация между узлами CouchDB»</a>, с помощью инкрементальной репликации CouchDB вы можете синхронизировать свои данные между любыми двумя базами данных так, как вам нравится и когда угодно. После репликации каждая база данных может работать независимо.
<p>Эту функцию можно использовать для синхронизации серверов баз данных в кластере или между центрами обработки данных с помощью планировщика заданий, например <em>cron</em>, или использовать его для синхронизации данных с ноутбуком для автономной работы во время поездок. Каждую базу данных можно использовать обычным способом, а изменения между базами данных можно синхронизировать позже в обоих направлениях.
<div class="figure" id="figure/4">

<img src="consistency/04.png">

<p class="caption">Рисунок 4. Инкрементная репликация между узлами CouchDB

</div>

<p>Что происходит, когда вы изменяете один и тот же документ в двух разных базах данных и хотите синхронизировать их друг с другом? Система репликации CouchDB поставляется с автоматическим обнаружением конфликтов <em>и</em> разрешением. Когда CouchDB обнаруживает, что документ был изменен в обеих базах данных, он помечает этот документ как конфликтующий, как в обычной системе контроля версий.
<p>Это не так хлопотно, как может показаться на первый взгляд. Если во время репликации конфликтуют две версии документа, <em> победившая</em> версия сохраняется как самая последняя версия в истории документа. Вместо того, чтобы выбросить <em> потерянную</em> версию, как вы могли ожидать, CouchDB сохраняет ее как предыдущую версию в истории документа, так что вы можете получить к ней доступ, если вам это нужно. Это происходит автоматически и последовательно, поэтому обе базы данных сделают один и тот же выбор.
<p>Вы сами решаете, как разрешить конфликты таким образом, который имеет смысл для вашего приложения. Вы можете оставить выбранные версии документов на месте, вернуться к более старой версии или попытаться объединить две версии и сохранить результат.
<h4 id="study">Учебный пример</h4>

<p>Грег Боренштейн, мой друг и коллега, создал небольшую библиотеку для преобразования списков воспроизведения Songbird в объекты JSON и решил сохранить их в CouchDB. как часть приложения резервного копирования. Законченное программное обеспечение использует MVCC и ревизии документов CouchDB, чтобы обеспечить надежное резервное копирование списков воспроизведения Songbird между узлами.
<div class="aside note">

<p>Songbird - это бесплатный программный медиаплеер со встроенным веб-браузером, основанный на платформе Mozilla XULRunner. Songbird доступен для Microsoft Windows, Apple Mac OS X, Solaris и Linux.
</div>

<p>Давайте рассмотрим рабочий процесс приложения резервного копирования Songbird: сначала пользователь выполняет резервное копирование с одного компьютера, а затем использует Songbird для синхронизации списков воспроизведения между несколькими компьютерами. Мы увидим, как редакции документов превращают проблему, которая могла бы стать проблемой, в то, что это <em>просто работает</em>.
<p>При первом использовании этого приложения для резервного копирования мы передаем наши списки воспроизведения в приложение и запускаем резервное копирование. Каждый список воспроизведения преобразуется в объект JSON и передается в базу данных CouchDB. Как показано на <a href="#figure/5"> рисунке 5 «Резервное копирование в одну базу данных»</a>, CouchDB возвращает идентификатор документа и ревизию каждого списка воспроизведения, когда он сохраняется в базе данных.
<div class="figure" id="figure/5">

<img src="consistency/05.png">

<p class="caption">Рисунок 5. Резервное копирование в одну базу данных

</div>

<p>Через несколько дней мы обнаруживаем, что наши плейлисты были обновлены, и мы хотим сохранить наши изменения. После того, как мы добавили наши списки воспроизведения в приложение резервного копирования, оно извлекает последние версии из CouchDB вместе с соответствующими версиями документа. Когда приложение возвращает новый список воспроизведения, CouchDB требует, чтобы редакция документа была включена в запрос.
<p>Затем CouchDB удостоверяется, что версия документа, переданная ему в запросе, соответствует текущей версии, хранящейся в базе данных. Поскольку CouchDB обновляет ревизию с каждой модификацией, если эти два не синхронизированы, это говорит о том, что кто-то еще внес изменения в документ между временем, когда мы запросили его из базы данных, и временем, когда мы отправили наши обновления. Внесение изменений в документ после того, как кто-то еще изменил его, без предварительной проверки этих изменений, обычно является плохой идеей.
<p>Требование к клиентам возвращать правильную версию документа - это главная часть оптимистичного параллелизма в CouchDB.
<p>У нас есть ноутбук, который мы хотим синхронизировать с настольным компьютером. При наличии всех наших плейлистов на рабочем столе, первым шагом является «восстановление из резервной копии» на наш ноутбук. Это первый раз, когда мы это делаем, поэтому после этого на нашем ноутбуке должна быть точная копия коллекции списков воспроизведения на рабочем столе.
<p>После редактирования нашего плейлиста «Аргентинское танго» на нашем ноутбуке, чтобы добавить несколько новых песен, которые мы приобрели, мы хотим сохранить наши изменения. Приложение резервного копирования заменяет документ списка воспроизведения в нашей базе данных CouchDB на ноутбуке, и создается новая версия документа. Несколько дней спустя мы вспоминаем наши новые песни и хотим скопировать плейлист на наш настольный компьютер. Как показано на <a href="#figure/6"> рисунке 6, «Синхронизация между двумя базами данных»</a>, приложение резервного копирования копирует новый документ и новую версию в настольную базу данных CouchDB. Обе базы данных CouchDB теперь имеют одинаковую редакцию документа.
<div class="figure" id="figure/6">

<img src="consistency/06.png">

<p class="caption">Рисунок 6. Синхронизация между двумя базами данных

</div>

<p>Поскольку CouchDB отслеживает изменения документа, он гарантирует, что подобные обновления будут работать, только если они основаны на текущей информации. Если бы мы внесли изменения в резервные копии списка воспроизведения между синхронизацией, все пошло бы не так гладко.
<p>Мы сохраняем некоторые изменения на нашем ноутбуке и забываем синхронизироваться. Несколько дней спустя мы редактируем списки воспроизведения на нашем настольном компьютере, делаем резервную копию и хотим синхронизировать это с нашим ноутбуком. Как показано в <a href="#figure/7"> Рисунок 7, «Конфликты синхронизации между двумя базами данных»</a>, когда наше приложение резервного копирования пытается выполнить репликацию между двумя базами данных, CouchDB видит, что изменения отправляющиеся из нашего настольного компьютера является модификацией устаревших документов и предупреждает нас о наличии конфликта.
<p>Восстановление после этой ошибки легко осуществить с точки зрения приложения. Просто скачайте версию плейлиста от CouchDB и предоставьте возможность объединить изменения или сохранить локальные модификации в новый плейлист.

<div class="figure" id="figure/7">

<img src="consistency/07.png">

<p class="caption">Рисунок 7. Синхронизация конфликтов между двумя базами данных

</div>

<h3 id="wrap">Заключение</h3>

<p>Дизайн CouchDB во многом заимствован из веб-архитектуры и многому научился у него. Это связано с использованием в этой архитектуре систем массового распределения. Поняв, почему эта архитектура работает так, как она работает, и научившись определять, какие части вашего приложения могут быть легко распределены, а какие нет, вы улучшите свои возможности по разработке распределенных и масштабируемых приложений с CouchDB или без него.
<p>Мы рассмотрели основные проблемы, связанные с моделью согласованности CouchDB, и намекнули на некоторые преимущества, которые вы получите, работая с <em>с</em> CouchDB, а не против него. Но хватит теории - давайте приступим к практике!
